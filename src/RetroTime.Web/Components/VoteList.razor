@using Microsoft.Extensions.Logging
@using RetroTime.Application.Common.Models
@using RetroTime.Application.Notifications.VoteChanged
@using RetroTime.Application.Retrospectives.Queries.GetRetrospectiveStatus
@using RetroTime.Application.Votes.Commands
@inherits MediatorComponent
@inject ILogger<VoteList> Logger
@using RetroTime.Application.Votes.Queries

@if (!RetrospectiveStatus.IsVotingAllowed && !RetrospectiveStatus.IsViewingVotesAllowed)
{
    return;
}

<div class="@CssClass" data-test-element-id="vote-list" data-id="@ItemId">
    @if (RetrospectiveStatus.IsVotingAllowed)
    {
        if (Votes.CanCastVote(CurrentParticipant.Id, Lane.Id) && !IsSaving) {
            <span class="vote-list__vote-button btn btn-sm btn-success text-white" @onclick="@DoVote">
                <i class="fas fa-thumbs-up"></i>
            </span>
        } else {
            <span class="vote-list__vote-button vote-list__vote-button--disabled btn btn-sm btn-success text-white disabled">
                <i class="far fa-thumbs-up"></i>
            </span>
        }
    }

    <ul class="vote-list__list">
        @foreach (VoteModel vote in TheVotes)
        {
            if (vote.ParticipantId == CurrentParticipant.Id && !IsSaving && RetrospectiveStatus.IsVotingAllowed)
            {
                <li class="vote-list__vote-remove-button btn btn-warning btn-sm rounded-5 me-1"
                    @onclick="@RetractVote"><Vote Color="@vote.ParticipantColor" IsCast="@vote.IsCast" /></li>
            }
            else
            {
                <li><Vote Color="@vote.ParticipantColor" IsCast="@vote.IsCast" /></li>
            }
        }
    </ul>
</div>


@code {
    [Parameter]
    public RetrospectiveNote? Note { get; set; }

    [Parameter]
    public RetrospectiveNoteGroup? NoteGroup { get; set; }

#nullable disable
    [CascadingParameter]
    public RetrospectiveLane Lane { get; set; }

    [CascadingParameter]
    public RetrospectiveVoteStatus Votes { get; set; }

    [CascadingParameter]
    public CurrentParticipantModel CurrentParticipant { get; set;  }

    [CascadingParameter]
    public RetrospectiveStatus RetrospectiveStatus { get; set; }
#nullable restore

    // Considered using generic instead, but this is more simple.
    private int ItemId => GetItem(Note?.Id, NoteGroup?.Id) ?? 0;
    private VoteLookup Lookup => GetItem(Votes.VotesByNote, Votes.VotesByNoteGroup);
    private IEnumerable<VoteModel> TheVotes => Lookup.Get(ItemId).Where(x => x.IsCast);
    private string CssClass => GetItem("note__vote-list vote-list", "note-group__vote-list vote-list");
    private bool IsSaving { get; set; }

    private T GetItem<T>(T ifNote, T ifGroup)
    {
        if (Note != null)
        {
            return ifNote;
        }

        if (NoteGroup != null)
        {
            return ifGroup;
        }

        throw new InvalidOperationException("Component not initialized");
    }

    private Task DoVote() => ExecuteVoteCommand(VoteMutationType.Added);
    private Task RetractVote() => ExecuteVoteCommand(VoteMutationType.Removed);

    private async Task ExecuteVoteCommand(VoteMutationType mutationType) {
        CastVoteCommand voteCommand = GetItem(CastVoteCommand.ForNote(ItemId, mutationType), CastVoteCommand.ForNoteGroup(ItemId, mutationType));

        IsSaving = true;
        try
        {
            await Mediator.Send(voteCommand);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error casting vote {mutationType} for item #{ItemId} [{CssClass}]");
        }
        finally
        {
            IsSaving = false;
        }

    }
}
